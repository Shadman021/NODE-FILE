S01 E01 => Basic Intro & History
# What is Node Js?
  Node.js is an open-source, cross-platform JavaScript runtime environment that allows developers to execute JavaScript code outside of a web browser. Traditionally, JavaScript was primarily used for client-side web development within browsers. Node.js, built on Google Chrome's V8 JavaScript engine, extended JavaScript's capabilities to the server-side and for building various other types of applications.

NOTE - Wherever there is JavaScript there will be JavaScript Engine.

S01 E02 => Node.js - Js on Server
# What is a Server?
  A server is a powerful computer that provides services, data, or programs to other computers (called clients) over a network. It's always on and ready to respond when someone (a client) asks for something, like a website, a file, or some information.
  For example:
  . When you open a website, your browser sends a request to the server where that website is stored.
  . The server receives the request, finds the website, and sends it back to your browser to display.

.Think of a server like a waiter in a restaurant 🍽️.
.You (the customer) ask the waiter (server) for food (data).
.The waiter goes to the kitchen (storage) and brings the food to your table.
.Similarly, a server brings information to your device when you ask for it (like when you search something or open a webpage).


Js Engine -> V8 - Google
             SpiderMonkey - FireFox
             Chakra - MicroSoft, InternetExplorer
             JavaScriptCore - Apple's Safari

# What is V8 Engine?
 Basic Defination:
  V8 is Google’s open source high-performance JavaScript and WebAssembly engine, written in C++. It is used in Chrome and in Node.js, among others. It implements ECMAScript and WebAssembly, and runs on Windows, macOS, and Linux systems that use x64, IA-32, or ARM processors. V8 can be embedded into any C++ application.

 Simple Defination:
  The V8 Engine is a JavaScript engine made by Google.
It is used to run JavaScript code inside your browser — mainly Google Chrome and also in Node.js (which is used for server-side JavaScript).

It’s called "V8" because it's fast — like a V8 car engine 🚗💨.

When you write JavaScript code, it’s just text. The V8 engine takes that text and converts it into machine code (code your computer understands) and runs it very fast.


ECMAScript - 
ECMAScript is the standard (or rulebook) for scripting languages like JavaScript.
It defines how the language should work — its syntax, features, and behavior.
JavaScript follows the ECMAScript standard, so all browsers know how to run it the same way.

eg - var name = "Shadman";
   - let age = 21;
   -const city = "Jamshedpur";


User Write ---> Js ---> Js Engine(c++ code) ---> Machine Code ---> Binary Code ---> Computer understands it.

Node.js is a C++ application with v8 embadded into it.

S01 E04
(09:13)
Whenever we create a seperate module, and want to require that module, so that we can run that module code, but we cannot access the variable, methods and functions just by simply requiring from one module to another module.
IMP - Modules by default protects there variables and functions from leaking.

And if we want to access that funtion from module to another module, I have to export that function and import it where I want to use that function.

(32:16)
Common JS Modules (CJS):
 -> module.exports
    require() 
 -> Bydefault used Node.js
 -> Older way
 -> Synchronous
 -> non-strict mode

ES Modules (ESM):(MJS)
 -> import
    export
 -> Bydefault used in React.js, Angular
 -> Newer Way
 -> Asynchronous
 -> strict mode

 (54:05)
 # What is module?
   A module is collection of JS code which is separate and private to itself,contains reusable code (like functions, variables, or classes) which you can import and use in other files. 
   To export a module we use : Module.exports = ...
   It helps in:
    - Organizing code better
    - Avoiding repetition
    - Keeping code clean and maintainable

(S01 E05)
# Why can't we access the variables and functions of the exported module that we require in our file?
  require("./path") OR How are variable and function private in different module?

  Because require wrapes all the code of that module inside the IIFE function, 
  like:
   function fun(){
    int a = 5;
    function fun1(){
      int b=4;
      console.log(b)
    }
  }
  console.log(a);

variable 'b' is inside is block scope so will be printed without any error; But when we try to print 'a', it will not print cause it is outside it’s block scole(" {} "); THAT SAME LOGIC applies in modules also, when we require the exported module, it wraps the required code inside a funtion (known as IIFE function), thats why we can't access it.

Proper language: When Node.js loads a module with require, it encapsulates the module's code within a function scope.
                 Variables and functions declared within this module are scoped to this function and not accessible globally.

(14:30)
IIFE - Immediatly Invoked Function Expression.

(function (){

})()

(21:41)
# How do you get access to module.export?
  Node.js passes module as a parameter to the IIFE

(24:44)
Five Steps mechanism of require:-
 1. Resolving the module
 2. Loading the module
 3. compiles module (Wraping module inside IIFE)
 4. Evaluation (Executing the Module Code)
 5. Caching the module

Resolving: Node finds the file/module path.
Loading: Node reads the file based on its type (.js, .json, etc.).
Wrapping: Code is wrapped in a function to create a private scope.
Evaluating: Node runs the wrapped code.
Caching: The result is stored, so future require() calls use the cached version.

(S01 E06)
(01:44)
"Node.js has an `event driven architecture` capable of `asynchronous I/O`."

(03:00)
JS is synchronous single threaded language.

(21:36)
Js is synchronous but with super powers of node it become/behave asynchronous.

and the super power is "LibUV"....

When JS has to access a file it asks LibUV for that, LibUV gets the file and give it to the JS.

(48:00)
LibUV if needed can talk to the timer, can make API calls, can read the files and talk to the database, and lot of things, and when ever it gets back the responce it gives it back to V8 engine. So V8 engine offloads these tasks(asynchronous) to LibUV, and LibUV completes all that.

few refrences to link them:
    V8 Engine and LibUV
1. Nobita & Doremon
2. Modi & Amit Sha
3. King & Queen(chess)

(S01 E07)
(42:50)
Synchronous Functions - WILL BLOCK THE MAIN THREAD - DON'T USE 

(S01 E08)
Google V8 JavaScript Engine:-

# What happens when you give your code to V8 engine?
  Inside V8 engine our code flow through different stages:-

  Stage 1: Parsing
    In parsing v8 engine converts our code to AST(Abstract Syntax Tree).But it can't be directly converted to AST, first our code will be broken into tokens and then AST will be built of tokens.

        Step 1 : Laxical Analysis

           First step to convert our code to AST is to pass through Laxical Analysis Phase(known as Tokenization). In  this step our code is converted to Tokens.
                           +--------+    +--------+
                           |  Code  |--->| Tokens |
                           +--------+    +--------+

        Step 2 : Syntax Analysis
           
           Also known as parsing, In this step tokens are converted to AST.
                           +--------+    +-----+
                           | Tokens |--->| AST |
                           +--------+    +-----+

  Stage 2: Interpretation / Compilation
    In this stage AST is passed through Ignition Interpreter and converted into Byte code
    and then it goes for Execution.
                           +-----+    +---------+------------+
                           | AST |--->| Ignition Interpreter |
                           +-----+    +---------+------------+
                                                |
                                           +----+-----+      .~~~~~~~~~~~.
                                           | ByteCode | ---> { Execution }
                                           +----+-----+      .~~~~~~~~~~~.
                                  
    JavaScript is JIT(Just In Timed ) Compilation, That means it has Interpreter and Compiler.

    So now where does compiler coems into picture is:                                                 
       
                                       +-----+                  Js compiler is known as TerboFan
                                       | AST |                     
                                       +-----+ 
                                          ⬇
                                          ⬇               Hot      Optimization
                               +----------+-----------+    Code    +----------+--------+   
                               | Ignition Interpreter |   ----->   | TerboFan Compiler |
                               +----------+-----------+            +------------+------+
                                          ⬇         ⬆                           ⬇
                                          ⬇         ⬆                           ⬇
                                    +-----+----+    ⬆ De-Optimization  +--------+---------------+
                                    | ByteCode |    ⬆ ⬅⬅⬅⬅⬅⬅⬅⬅  | Optimized Machine Code |  
                                    +-----+----+                       +--------+---------------+
                                          ⬇          .~~~~~~~~~~~.              ⬇
                                          ➡➡➡➡➡  { Execution } ⬅⬅⬅⬅⬅⬅⬅⬅ 
                                                     .~~~~~~~~~~~.
                              
    When AST is given to Ignition Interpreter it converts it to ByteCode but when it see's repeatable code(HOT code) like function, variable or any piece of code it passes it to TerboFan Compiler, and TerboFan Compiler converts that Hot code to optimized machine code, after that it again executed, This portion is known as Optimization.

(S01 E09)
We know that node has two main components,
 - V8 Engine
 - LibUV

This video will focus on lib.uv....

Lets start with, what's inside Libuv?
    Inside libuv there are 3 major components,                     Lib.uv
      - Event Loop                                 +---------------------------------------+
      - Callback Queues                            |  +------>-----+                       |
      - Thread Pool                                |  | Event loop |                       |
                                                   |  +------<-----+   +--+  +--+          |
                                                   |                   |  |  |  |          |
                                                   |   ---------       +--+  +--+ Thread   |
                                                   |   ---------       +--+  +--+    Pool  |
                                                   |   ---------       |  |  |  |          |
                                                   |   ---------       +--+  +--+          |
                                                   | Callback Queue                        | 
                                                   +---------------------------------------+

    Event Loop :-
      There are 4 major phases of event loop.            Event Loop
      - Timer Phase                                +-------+      +------+
      - Poll  Phase                                | Timer | ---> | Poll |
      - Check Phase                                +-------+      +------+                             
      - Close Phase                                    ⬆              ⬇
                                                   +-------+      +-------+
                                                   | Close | <--- | Check |
                                                   +-------+      +-------+                                      
     1: Timer Phase - Executes callbacks at specific intervals or once after a specified delay.
                      setTimeOut, setInterval.
     2: Poll Phase - Handles I/O operations like reading from or writing to files, sockets, or other streams.
                     I/O callbacks
                     incoming connection
                     data
                     fs, crypto, http.get
     3: Check Phase - Executes callbacks immediately after the polling phase completes.
                      setImmediate
     4: Close Phase - Cleans up resources associated with handles that are closed or destroyed.

                                +-------+                   +------+
                                | Timer | ----------------> | Poll |
                                +-------+                   +------+
                                    ⬆  ⬆ ⬇                 ⬇ ⬆  ⬇
                                    ⬆   +-------------------+   ⬇
           Priority                 ⬆   | Process.next Tick |   ⬇
             Cycle                  ⬆   +-------------------+   ⬇
                                    ⬆       ⬇           ⬆       ⬇
                                    ⬆    +-----------------+    ⬇
                                    ⬆    |Promise Callback |    ⬇
                                    ⬆    +-----------------+    ⬇
                                    ⬆                           ⬇
                                    ⬆   ⬆ ⬇                ⬇ ⬆  ⬇
                                +-------+                   +-------+
                                | Close | <---------------- | Check |
                                +-------+                   +-------+

    NOTE : Priority cycle is executed before evry phase of event loop

(S01 E10)
# Is Node.js single threaded or multitreaded?
     Node.js is both single-threaded and multi-threaded — depending on which part you're talking about:

     Node.js is primarily single-threaded in the way it executes JavaScript code. It runs on the V8 engine and uses a single main thread for handling all JavaScript logic, relying on an event loop to manage asynchronous operations without blocking the thread.

     However, under the hood, Node.js uses a multi-threaded architecture thanks to the libuv library, which manages a thread pool (typically 4 threads) to handle heavy tasks like file system operations, cryptography, and DNS lookups. This allows Node.js to perform non-blocking I/O efficiently.

(05:29)
One cycle of event loop is called one Tick.

(31:00)
UV_THREADPOOL_SIZE= 4 (By default)

READ ABOUT :- 
 1. LibUV's Event loop, thread pool, callback queue
 2. Epoll
 3. Kqueue
 4. fds-socket descriptions

(S01 E11) - 
# How web works
# How user makes a request to a server and how and how it gets back the responce